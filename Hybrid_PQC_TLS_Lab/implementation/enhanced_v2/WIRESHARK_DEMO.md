# Wireshark 抓包演示指南 - 展示混合TLS协议

本文档说明如何使用 Wireshark 抓包来直观展示代理服务器实现的混合 TLS 协议架构。

---

## 🎯 核心展示目标

**展示双重 TLS 架构：**
1. **浏览器 ↔ 代理服务器（8080端口）**：标准 TLS 1.2/1.3
2. **代理服务器 ↔ 后端服务器（8443端口）**：自定义混合 PQC-TLS

---

## 📊 最重要的包（按优先级）

### ⭐⭐⭐ 第一优先级：展示双重 TLS 架构

#### 1. **浏览器 → 代理服务器：标准 TLS 握手**

**过滤器：**
```
tcp.port == 8080 and tls.handshake.type == 1 and ip.src == 127.0.0.1
```

**要查看的包：**
- `Client Hello`：浏览器发送的标准 TLS ClientHello
- `Server Hello`：代理服务器响应的标准 TLS ServerHello
- `Certificate`：代理服务器的自签名证书
- `Application Data`：加密的 HTTP 请求

**为什么重要：**
- ✅ 证明浏览器使用标准 TLS 与代理通信
- ✅ 展示代理服务器作为标准 HTTPS 服务器

**展示方法：**
1. 右键包 → `Follow` → `TLS Stream`
2. 可以看到标准的 TLS 1.2/1.3 握手过程

---

#### 2. **代理服务器 → 后端服务器：自定义混合 TLS**

**过滤器：**
```
tcp.port == 8443 and ip.addr == 127.0.0.1
```

**要查看的包：**
- 第一个包：自定义 TLS ClientHello（不是标准格式）
- ServerHello：后端服务器的响应
- Certificate：包含后量子扩展的证书
- CertificateVerify：大尺寸的后量子签名（ML-DSA-65约3309字节）

**为什么重要：**
- ✅ 证明代理使用自定义 TLS 协议与后端通信
- ✅ 展示后量子密码学算法（大签名、自定义格式）

**展示方法：**
1. 右键包 → `Follow` → `TCP Stream`
2. 可以看到自定义 TLS 协议的原始数据
3. 注意：这些包**不是**标准的 TLS 格式，无法用 Wireshark 的 TLS 解析器解析

---

#### 3. **HTTP CONNECT 请求（关键！）**

**过滤器：**
```
http.request.method == "CONNECT" and tcp.port == 8080
```

**要查看的包：**
- HTTP CONNECT 请求：`CONNECT pqc-tls.local:8443 HTTP/1.1`
- `200 Connection Established` 响应

**为什么重要：**
- ✅ 证明浏览器通过代理访问后端服务器
- ✅ 展示代理服务器的核心功能：隧道建立

**展示方法：**
1. 右键包 → `Follow` → `HTTP Stream`
2. 可以看到完整的 CONNECT 请求和响应

---

### ⭐⭐ 第二优先级：展示数据转发

#### 4. **双向数据流对比**

**过滤器：**
```
(tcp.port == 8080 or tcp.port == 8443) and ip.addr == 127.0.0.1 and tcp.len > 0
```

**要查看的包：**
- 浏览器 → 代理（8080端口）：标准 TLS 加密数据
- 代理 → 后端（8443端口）：自定义 TLS 加密数据
- 后端 → 代理（8443端口）：自定义 TLS 加密数据
- 代理 → 浏览器（8080端口）：标准 TLS 加密数据

**为什么重要：**
- ✅ 展示数据在两个 TLS 层之间的转换
- ✅ 证明代理服务器作为"协议转换器"

**展示方法：**
1. 使用时间线视图，可以看到数据包的时序关系
2. 对比两个端口的数据包大小和格式

---

### ⭐ 第三优先级：展示后量子特征

#### 5. **大尺寸签名包**

**过滤器：**
```
tcp.port == 8443 and tcp.len > 3000
```

**要查看的包：**
- CertificateVerify 消息：包含 ML-DSA-65 签名（约3309字节）
- 对比标准 TLS 的签名大小（通常 < 512字节）

**为什么重要：**
- ✅ 直观展示后量子签名的"大尺寸"特征
- ✅ 证明使用了后量子密码学算法

**展示方法：**
1. 查看包的 `Length` 字段
2. 对比标准 TLS 和混合 TLS 的包大小

---

## 🔍 推荐的 Wireshark 显示配置

### 1. 添加自定义列

**添加以下列以便快速识别：**

1. **协议类型列**：
   - 右键列标题 → `Column Preferences`
   - 添加列：`Protocol`（如果还没有）

2. **数据长度列**：
   - 添加列：`Length` 或 `tcp.len`
   - 用于识别大尺寸的后量子签名

3. **端口列**：
   - 添加列：`Source Port` 和 `Destination Port`
   - 用于区分两个 TLS 层

---

### 2. 使用颜色规则

**创建颜色规则以便快速识别：**

1. **标准 TLS（浏览器 ↔ 代理）**：
   - 条件：`tcp.port == 8080 and tls`
   - 颜色：蓝色

2. **自定义 TLS（代理 ↔ 后端）**：
   - 条件：`tcp.port == 8443`
   - 颜色：绿色

3. **CONNECT 请求**：
   - 条件：`http.request.method == "CONNECT"`
   - 颜色：黄色

4. **大尺寸包（后量子签名）**：
   - 条件：`tcp.len > 3000`
   - 颜色：红色

**设置方法：**
- `View` → `Coloring Rules` → `+` 添加规则

---

## 📋 演示步骤（按顺序）

### 步骤 1：准备抓包

1. **启动 Wireshark**
   - 选择 `Loopback` 接口
   - 设置过滤器：`(tcp.port == 8080 or tcp.port == 8443) and ip.addr == 127.0.0.1`

2. **启动服务器**
   ```bash
   # 终端1：启动后端服务器
   cd implementation/enhanced_v2_by_val
   python enhanced_server.py
   
   # 终端2：启动代理服务器
   cd implementation/enhanced_v2
   python https_proxy.py
   ```

3. **开始抓包**
   - 点击 Wireshark 的绿色鲨鱼图标开始捕获

---

### 步骤 2：触发连接

1. **浏览器访问**
   - 访问：`https://pqc-tls.local:8443`
   - 处理证书警告

2. **观察数据包**
   - 应该能看到数据包开始出现

---

### 步骤 3：展示关键包

#### 3.1 展示 CONNECT 请求

**操作：**
1. 使用过滤器：`http.request.method == "CONNECT"`
2. 找到第一个 CONNECT 包
3. 右键 → `Follow` → `HTTP Stream`
4. **展示内容：**
   ```
   CONNECT pqc-tls.local:8443 HTTP/1.1
   Host: pqc-tls.local:8443
   
   HTTP/1.1 200 Connection Established
   ```

**说明：**
> "这是浏览器通过代理服务器建立隧道的请求。浏览器请求连接到 `pqc-tls.local:8443`，代理服务器响应 `200 Connection Established`，表示隧道已建立。"

---

#### 3.2 展示标准 TLS 握手（浏览器 ↔ 代理）

**操作：**
1. 使用过滤器：`tcp.port == 8080 and tls.handshake.type == 1`
2. 找到 ClientHello 包
3. 右键 → `Follow` → `TLS Stream`
4. **展示内容：**
   - ClientHello（浏览器）
   - ServerHello（代理）
   - Certificate（代理的自签名证书）
   - Application Data（加密的 HTTP 请求）

**说明：**
> "这是浏览器和代理服务器之间的标准 TLS 握手。浏览器使用标准的 TLS 1.2/1.3 协议与代理通信，这是标准的 HTTPS 通信。"

---

#### 3.3 展示自定义 TLS 握手（代理 ↔ 后端）

**操作：**
1. 使用过滤器：`tcp.port == 8443`
2. 找到第一个包（自定义 ClientHello）
3. 右键 → `Follow` → `TCP Stream`
4. **展示内容：**
   - 自定义格式的握手消息
   - 大尺寸的 CertificateVerify（后量子签名）

**说明：**
> "这是代理服务器和后端服务器之间的自定义混合 TLS 握手。注意这些包不是标准的 TLS 格式，Wireshark 无法解析为 TLS，因为这是我们自定义的协议。可以看到 CertificateVerify 消息非常大（约3309字节），这是因为使用了 ML-DSA-65 后量子签名算法。"

---

#### 3.4 对比数据包大小

**操作：**
1. 使用过滤器：`tcp.port == 8443 and tcp.len > 3000`
2. 找到大尺寸包
3. 查看 `Length` 列

**说明：**
> "这是后量子签名的特征。ML-DSA-65 签名约3309字节，而传统 RSA-2048 签名只有256字节。这直观展示了后量子密码学的'大尺寸'特征。"

---

#### 3.5 展示数据转发流程

**操作：**
1. 使用过滤器：`(tcp.port == 8080 or tcp.port == 8443) and tcp.len > 0`
2. 按时间排序
3. 展示数据包的时序关系

**说明：**
> "可以看到数据在两个 TLS 层之间流动：
> 1. 浏览器发送标准 TLS 加密的 HTTP 请求到代理（8080端口）
> 2. 代理解密后，使用自定义 TLS 加密转发到后端（8443端口）
> 3. 后端使用自定义 TLS 加密响应
> 4. 代理解密后，使用标准 TLS 加密转发回浏览器
> 
> 这就是代理服务器的核心功能：在标准 TLS 和自定义混合 TLS 之间进行协议转换。"

---

## 🎬 演示脚本（推荐顺序）

### 1. 开场：展示架构图
```
浏览器 (标准TLS) ←→ 代理服务器 (8080) ←→ 后端服务器 (8443, 自定义TLS)
```

### 2. 展示 CONNECT 请求
- 过滤器：`http.request.method == "CONNECT"`
- 说明：浏览器通过代理建立隧道

### 3. 展示标准 TLS（浏览器 ↔ 代理）
- 过滤器：`tcp.port == 8080 and tls`
- 说明：浏览器使用标准 TLS

### 4. 展示自定义 TLS（代理 ↔ 后端）
- 过滤器：`tcp.port == 8443`
- 说明：代理使用自定义混合 TLS

### 5. 对比签名大小
- 过滤器：`tcp.len > 3000`
- 说明：后量子签名的大尺寸特征

### 6. 展示完整数据流
- 过滤器：`(tcp.port == 8080 or tcp.port == 8443)`
- 说明：数据在两个 TLS 层之间的转换

---

## 📸 截图建议

### 关键截图 1：CONNECT 请求
- 显示 HTTP CONNECT 请求和响应
- 标注：浏览器通过代理建立隧道

### 关键截图 2：双重 TLS 架构
- 左侧：标准 TLS 握手（8080端口）
- 右侧：自定义 TLS 握手（8443端口）
- 标注：两个不同的 TLS 层

### 关键截图 3：大尺寸签名
- 显示 CertificateVerify 包的大小
- 对比标准 TLS 签名大小
- 标注：后量子签名的特征

### 关键截图 4：数据流时序
- 显示数据包的时间线
- 标注：数据在两个 TLS 层之间的流动

---

## 💡 演示要点总结

### 核心展示内容：

1. ✅ **双重 TLS 架构**
   - 浏览器 ↔ 代理：标准 TLS
   - 代理 ↔ 后端：自定义混合 TLS

2. ✅ **协议转换功能**
   - 代理服务器在两个协议之间转换
   - 数据在两个 TLS 层之间流动

3. ✅ **后量子密码学特征**
   - 大尺寸签名（ML-DSA-65）
   - 自定义协议格式

4. ✅ **实际应用场景**
   - 浏览器可以使用标准 HTTPS
   - 后端使用后量子 TLS
   - 通过代理实现无缝连接

---

## 🔧 故障排除

### 如果看不到包：

1. **检查过滤器**
   ```
   ip.addr == 127.0.0.1
   ```

2. **检查接口**
   - 确保选择了 Loopback 接口
   - Windows：可能需要安装 Npcap

3. **检查服务器**
   - 确认后端服务器在 8443 端口监听
   - 确认代理服务器在 8080 端口监听

4. **检查浏览器**
   - 确认使用了 `https://pqc-tls.local:8443`
   - 确认代理配置正确

---

## 📚 相关文档

- [浏览器设置指南](./BROWSER_SETUP.md)
- [代理服务器说明](./README_HTTPS.md)

